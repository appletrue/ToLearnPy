# 正则表达式

1. 正则表达式简介
2. 正则表达式中的字符
3. 元字符详解
4. 常用正则表达式实例
5. 正则表达式的匹配过程
6. 正则表达式中的标志位-flag

==========================================================



## 1、 什么是正则表达式

——**本质上是一个小巧的、高度专用的编程语言**

正则表达式，又称规则表达式（Regular Expression，一般简写为regex，regexp，或RE，re)。用来匹配、检索、替换符合某个模式规则的文本。

表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

## 2、正则表达式能做什么？验证/搜索/替换

正则表达式的主要应用对象是文本，使用正则表达式可以指定想要匹配的字符串规则，然后通过这个规则来匹配、查找、替换或切割那些符合指定规则的文本。总体来讲，正则表达式可以对指定的文本实现以下功能：

- **查找与替换：** 判断给定字符串中是否包含满足正则表达式所指定的匹配规则的子串，如查找一段文本中的所包含的IP地址。另外，还可以对查找到的子串进行内容替换。可用于查找特定条件的字符串
  可用于某些工具(vi,grep,find等)中进行模式匹配和替换


- **匹配验证：** 判断给定的字符串是否符合正则表达式所指定的过滤规则，从而可以判断某个字符串的内容是否符合特定的规则（如email地址、手机号码等）；当正则表达式用于匹配验证时，通常需要在正则表达式字符串的首部和尾部加上^和$，以匹配整个待验证的字符串。
- **字符串分割与子串截取：** 基于子串查找功能还可以以符合正则表达式所指定的匹配规则的字符串作为分隔符对给定的字符串进行分割。

## 3、优先权顺序

| 操作符                       | 描述      |
| ------------------------- | ------- |
| \                         | 转义符     |
| (), (?:), (?=), []        | 圆括号和方括号 |
| *, +, ?, {n}, {n,}, {n,m} | 限定符     |
| ^, $, \anymetacharacter   | 位置和顺序   |

## 4、正则表达式中的字符

正则表达式的主要应用对象是文本，其最基础的功能是文本匹配，而文本是由一个个的字符组成，因此正则表达式实际上是对字符的匹配。

- 普通字符

大小写的字母和数字，如数字（0-9），字母（a-z, A-Z）等





- 元字符

具有特殊的含义的字符，特殊元字符包括：`[` `]` `\` `^` `$` `.` `|` `?` `*` `+` `(` `)`

## 5、元字符

| 字符          | 描述                                       |              |      |
| ----------- | ---------------------------------------- | ------------ | ---- |
| \           | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。 | 'n' 匹配字符 "n" |      |
| ^           | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 |              |      |
| $           | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 |              |      |
| *           | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |              |      |
| +           | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |              |      |
| ?           | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。 |              |      |
| {n}         | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |              |      |
| {n,}        | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |              |      |
| {n,m}       | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |              |      |
| ?           | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。 |              |      |
| .           | 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。 |              |      |
| (pattern)   | 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。 |              |      |
| (?:pattern) | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (\|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y\|ies) 就是一个比 'industry\|industries' 更简略的表达式。 |              |      |
| (?=pattern) | 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95\|98\|NT\|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |              |      |
| (?!pattern) | 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95\|98\|NT\|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |              |      |
| x\|y        | 匹配 x 或 y。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"。 |              |      |
| [xyz]       | 字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。 |              |      |
| [^xyz]      | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。 |              |      |
| [a-z]       | 字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。 |              |      |
| [^a-z]      | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。 |              |      |
| \b          | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |              |      |
| \B          | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |              |      |
| \cx         | 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |              |      |
| \d          | 匹配一个数字字符。等价于 [0-9]。                      |              |      |
| \D          | 匹配一个非数字字符。等价于 `[^0-9]`                   |              |      |
| \f          | 匹配一个换页符。等价于 \x0c 和 \cL。                  |              |      |
| \n          | 匹配一个换行符。等价于 \x0a 和 \cJ。                  |              |      |
| \r          | 匹配一个回车符。等价于 \x0d 和 \cM。                  |              |      |
| \s          | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |              |      |
| \S          | 匹配任何非空白字符。等价于` [^ \f\n\r\t\v]`           |              |      |
| \t          | 匹配一个制表符。等价于 \x09 和 \cI。                  |              |      |
| \v          | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                |              |      |
| \w          | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。        |              |      |
| \W          | 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'            |              |      |
| \xn         | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。 |              |      |
| \num        | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。 |              |      |
| \n          | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |              |      |
| \nm         | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |              |      |
| \nml        | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |              |      |

## 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。

正则表达式的限定符有：

| 字符    | 描述                                       |
| ----- | ---------------------------------------- |
| *     | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +     | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?     | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。 |
| {n}   | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}  | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m} | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

## 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，\b描述单词的前或后边界，\B表示非单词边界。

正则表达式的限定符有：

| 字符   | 描述                                       |
| ---- | ---------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个字边界，即字与空格间的位置。                       |
| \B   | 非字边界匹配。                                  |

**注意**：不能将限定符与定位点一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。

若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。

若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。

若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：

正则表达式匹配实例

正则表达式的匹配 (1)
	fo+ 
	可以与目标对象中的 “fool”, “fo”, 或者 “football”等在字母f后面连续出现一个或多个字母o的字符串相匹配 
	eg*
	与目标对象中的 “easy”, “ego”, 或者 “egg”等在字母e后面连续出现零个或多个字母g的字符串相匹配 
	Wil?
	与目标对象中的”Win”,“Wilson”等在字母i后面连续出现零个或一个字母l的字符串相匹配 
	Jim\{2,6\}
	规定字符m可以在匹配对象中连续出现2-6次，可以同jimmy或jimmmmmy等字符串相匹配
正则表达式的匹配 (2)
	^hell 
	以 “hell”, “hello”或 “hellhound”开头的字符串 
	ar$
	以 “car”, “bar”或 “ar” 结尾的字符串 
	[A-Z]
	A到Z范围内任何一个大写字母相匹配 
	[a-z]
	从a到z范围内任何一个小写字母相匹配 

正则表达式的匹配 (3)
	[0-9]
	从0到9范围内任何一个数字 
	([a-z][A-Z][0-9])+
	任何由字母和数字组成的字符串
	to|too|2 
	与目标对象中的 “to”, “too”, 或 “2” 相匹配 
	[^A-C]
	与目标对象中除A，B，和C之外的任何字符相匹配 


正则表达式应用

正则表达式在find中的应用
 find /dev/ �Cname tty[0-9]
在/dev下查找以tty开头，后面跟一个数字的文件

正则表达式在grep中的应用
文本文件phone.txt内容如下：
Francis, John      5-3871 
Wong, Fred        4-4123 
Jones, Thomas    1-4122 
Salazar, Richard 5-2522 

grep 命令
1) grep '^S[^ ]* R' phone.txt
2) grep '^[JW]'   phone.txt
3) grep -v '^[JW]' phone.txt
4) grep '^[M-Z]' phone.txt
5) grep '^[M-Z].*[12]' phone.txt 

正则表达式在vi中的应用
	Vi的替换命令
	:ranges/pat1/pat2/
	range 是命令执行范围的指定 
	pat1 查找的一个正则表达式 
	pat2 这是希望把匹配串变成的模式的正则表达式 



正则表达式在vi中的应用--例1
	:%s/  */ /g     把一个或者多个空格替换为一个空格。
	:%s/ *$//      去掉行尾的所有空格。
	:%s/^/ /        在每一行头上加入一个空格。
	:%s/^[0-9][0-9]*//  去掉行首的所有数字字符。
	:%s/b[aeio]g/bug/g  将所有的bag、beg、big和bog改为bug。
	:%s/t\([aou]\)g/h\1t/g   将所有tag、tog和tug分别改为hat、hot和hug（注意用group的用法和使用\1引用前面被匹配的字符）。
正则表达式在vi中的应用--例2
将a,b,c的实例改为b,a,c
正则表达式在vi中的应用--例2
	:%s/\([^,]*\),\([^,]*\),/\2,\1,/g 
	解释
	[^,]      除了逗号之外的任何字符
	[^,]*   0或者多个非逗号字符
	\([^,]*\) 将这些非逗号字符标记为\1，这样可以在之后的替换模式表达式中引用它
	\([^,]*\), 我们必须找到0或者多个非逗号字符后面跟着一个逗号，并且非逗号字符那部分要标记出来以备后用。

正则表达式在vi中的应用--例3
文本文件
Billy tried really hard 
Sally tried really really hard 
Timmy tried really really really hard 
Johnny tried really really really really hard
转化为
Billy tried very hard 
Sally tried very hard 
Timmy tried very hard 
Johnny tried very hard
正则表达式在vi中的应用--例3
:%s/\(really \)\(really \)*/very /

表达式\(really \)*匹配0或多个连续的"really "（注意结尾有个空格），而\(really \)\(really \)* 匹配1个或多个连续的"really "实例。 

-----------------------------------------------------
python中的正则使用

re模块
	python通过使用re模块，获得全部正则表达式的功能。
-----------------------------
re.match函数
	re.match(pattern, string, flags=0)

函数参数
参数	描述
pattern	匹配的正则表达式
string	要匹配的字符串。
flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

匹配成功re.match方法返回一个匹配的对象，否则返回None。
我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。
匹配对象方法	描述
group(num=0)	匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。
groups()	返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。

示例：
import re
print(re.match('www', 'www.baidu.com'))  # 在起始位置匹配
print(re.match('com', 'www.baidu.com'))         # 不在起始位置匹配

(0, 3)
None

示例：
import re

line = "Page is a pig"

matchObj = re.match( r'(.*) is a (.*)', line, re.I)

if matchObj:
   print "matchObj.group() : ", matchObj.group()
   print "matchObj.group(1) : ", matchObj.group(1)
   print "matchObj.group(2) : ", matchObj.group(2)
else:
   print "No match!!"

结果：
matchObj.group() :  Page is a pig
matchObj.group(1) :  Page
matchObj.group(2) :  pig

-------------------------
re.search函数
re.search 扫描整个字符串并返回第一个成功的匹配。
函数语法：
	re.search(pattern, string, flags=0)

函数参数说明：
参数	描述
pattern	匹配的正则表达式
string	要匹配的字符串。
flags	标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

匹配成功re.search方法返回一个匹配的对象，否则返回None。
我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。
匹配对象方法	描述
group(num=0)	匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。
groups()	返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。

示例：
print(re.search('www', 'www.baidu.com'))  # 在起始位置匹配
print(re.search('com', 'www.baidu.com'))         # 不在起始位置匹配



re.match与re.search的区别
re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。
-------------------------
re.sub函数
re.sub用于替换字符串中的匹配项。
	re.sub(pattern, repl, string, count=0, flags=0)

参数：
pattern : 正则中的模式字符串。
repl : 替换的字符串，也可为一个函数。
string : 要被查找替换的原始字符串。
count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。

示例：
import re

phone = "0086-10-12345678 # 这是一个国内北京的电话号码"

# 删除字符串中的 Python注释 
num = re.sub(r'#.*$', "", phone)
print "电话号码是: ", num

# 删除非数字(-)的字符串 
num = re.sub(r'\D', "", phone)
print "电话号码是 : ", num

---------------------------------
repl可以是一个函数
示例：
将字符串中的匹配的数字乘于 2
import re

# 将匹配的数字乘于 2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)

s = '321+123=444'
print(re.sub('(?P<value>\d+)', double, s))

结果：
642+246=888

-------------------------------------------------------
正则表达式修饰符 - 可选标志
修饰符	描述
re.I	使匹配对大小写不敏感
re.L	做本地化识别（locale-aware）匹配
re.M	多行匹配，影响 ^ 和 $
re.S	使 . 匹配包括换行在内的所有字符
re.U	根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
re.X	该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。

-----------------------------------------------------
正则模式

模式	描述
^	匹配字符串的开头
$	匹配字符串的末尾。
.	匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
[...]	用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'
[^...]	不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
re*	匹配0个或多个的表达式。
re+	匹配1个或多个的表达式。
re?	匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式
re{ n}	
re{ n,}	精确匹配n个前面表达式。
re{ n, m}	匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
a| b	匹配a或b
(re)	G匹配括号内的表达式，也表示一个组
(?imx)	正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
(?-imx)	正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
(?: re)	类似 (...), 但是不表示一个组
(?imx: re)	在括号中使用i, m, 或 x 可选标志
(?-imx: re)	在括号中不使用i, m, 或 x 可选标志
(?#...)	注释.
(?= re)	前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
(?! re)	前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
(?> re)	匹配的独立模式，省去回溯。
\w	匹配字母数字及下划线
\W	匹配非字母数字及下划线
\s	匹配任意空白字符，等价于 [\t\n\r\f].
\S	匹配任意非空字符
\d	匹配任意数字，等价于 [0-9].
\D	匹配任意非数字
\A	匹配字符串开始
\Z	匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c
\z	匹配字符串结束
\G	匹配最后匹配完成的位置。
\b	匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B	匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\n, \t, 等.	匹配一个换行符。匹配一个制表符。等
\1...\9	匹配第n个分组的内容。
\10	匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。



--------------------------------------------------------------------
正则表达式实例
字符匹配
实例	描述
python	匹配 "python".
字符类
实例	描述
[Pp]ython	匹配 "Python" 或 "python"
rub[ye]	匹配 "ruby" 或 "rube"
[aeiou]	匹配中括号内的任意一个字母
[0-9]	匹配任何数字。类似于 [0123456789]
[a-z]	匹配任何小写字母
[A-Z]	匹配任何大写字母
[a-zA-Z0-9]	匹配任何字母及数字
[^aeiou]	除了aeiou字母以外的所有字符
[^0-9]	匹配除了数字外的字符
特殊字符类
实例	描述
.	匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。
\d	匹配一个数字字符。等价于 [0-9]。
\D	匹配一个非数字字符。等价于 [^0-9]。
\s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\w	匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
\W	匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。